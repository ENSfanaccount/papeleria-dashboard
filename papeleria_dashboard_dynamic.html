<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Papelería Lupita — Dashboard dinámico (Jul-Sep 2024)</title>

  <!-- Tailwind CDN (para estilo rápido y responsivo) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    /* pequeños ajustes visuales */
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f3f4f6; color:#0f172a; }
    .card { background:white; border-radius:12px; padding:16px; box-shadow:0 6px 18px rgba(15,23,42,0.06); }
    canvas { max-height:380px; width:100% !important; }
    .small-note { font-size:0.9rem; color:#374151; }
    .badge { background:#eef2ff; color:#1e3a8a; padding:4px 8px; border-radius:999px; font-weight:600; font-size:0.8rem; }
    .alert { background:#fff7ed; border-left:4px solid #f59e0b; padding:10px; border-radius:8px; color:#92400e; }
    table th, table td { padding:10px; border-bottom:1px solid #eef2f6; text-align:left; }
    @media (max-width: 900px) { canvas { max-height:260px; } }
  </style>
</head>
<body class="p-6">

  <header class="max-w-6xl mx-auto mb-6">
    <div class="flex items-start justify-between">
      <div>
        <h1 class="text-2xl font-semibold">Papelería Lupita — Dashboard dinámico</h1>
        <p class="small-note mt-1">Sube tus archivos CSV (ventas e inventario) y el dashboard recalculará todo automáticamente. Periodo objetivo: <strong>1 Jul 2024 — 30 Sep 2024</strong>.</p>
      </div>
      <div class="text-right">
        <div class="badge">Datos: Julio - Septiembre 2024</div>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto space-y-6">

    <!-- Upload -->
    <section class="card flex flex-col md:flex-row gap-4 items-center">
      <div class="flex-1">
        <div class="font-medium">Carga los archivos CSV</div>
        <div class="small-note mt-1">Seleccione los CSV que contienen tus registros de ventas e inventario. Columnas esperadas (heurísticas): <em>fecha, producto, categoria, cantidad, precio, costo, vendedor/empleado, metodo_pago, stock, stock_min</em>.</div>
      </div>
      <div class="flex gap-3 items-center">
        <label class="block">
          <span class="text-sm font-medium">Ventas (CSV)</span>
          <input id="fileVentas" type="file" accept=".csv" class="mt-1 block" />
        </label>

        <label class="block">
          <span class="text-sm font-medium">Inventario (CSV)</span>
          <input id="fileInv" type="file" accept=".csv" class="mt-1 block" />
        </label>

        <button id="btnProcess" class="ml-2 px-4 py-2 bg-sky-600 text-white rounded">Procesar</button>
      </div>
    </section>

    <!-- Summary cards -->
    <section class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div class="card">
        <div class="flex items-center justify-between">
          <div>
            <div class="text-xs text-gray-500">Ingresos totales (Jul-Sep 2024)</div>
            <div id="totalRevenue" class="text-xl font-semibold mt-1">—</div>
          </div>
          <div class="text-right small-note">
            <div id="daysCount">Fechas registradas: —</div>
            <div id="peakAug">Pico ago: —</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="text-xs text-gray-500">Mejor vendedor</div>
        <div class="mt-1 text-lg font-semibold" id="bestSeller">—</div>
        <div class="small-note mt-2" id="sellerDetails">—</div>
      </div>

      <div class="card">
        <div class="text-xs text-gray-500">Alertas de inventario</div>
        <div id="alertsCount" class="mt-1 text-lg font-semibold">—</div>
        <div class="small-note mt-2">Productos con stock < stock mínimo</div>
      </div>
    </section>

    <!-- GRID charts -->
    <section class="grid grid-cols-1 lg:grid-cols-2 gap-4">
      <div class="card">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-lg font-medium">Tendencia de ventas (diaria)</h2>
          <div class="small-note">Línea — muestra el pico de regreso a clases</div>
        </div>
        <canvas id="chartDaily"></canvas>
        <div id="dailyNote" class="mt-3 small-note"></div>
      </div>

      <div class="card">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-lg font-medium">Desempeño por categoría</h2>
          <div class="small-note">Ingresos y % del total</div>
        </div>
        <canvas id="chartCategory"></canvas>
        <div id="categoryLegend" class="mt-3 small-note"></div>
      </div>

      <div class="card lg:col-span-1">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-lg font-medium">Márgenes de ganancia (por producto)</h2>
          <div class="small-note">Si faltan costos, verás aviso</div>
        </div>
        <canvas id="chartMargin"></canvas>
        <div id="marginNote" class="mt-3 small-note"></div>
      </div>

      <div class="card lg:col-span-1">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-lg font-medium">Comparación empleados</h2>
          <div class="small-note">Ingresos por empleado — y método de pago (si existe)</div>
        </div>
        <canvas id="chartEmp"></canvas>
        <div id="empNote" class="mt-3 small-note"></div>
      </div>
    </section>

    <!-- Inventory alerts table -->
    <section class="card">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-medium">Alertas de inventario — reorden</h2>
        <div class="small-note">Productos con stock debajo de stock mínimo (mapeo por nombres comunes)</div>
      </div>

      <div id="alertsWrapper">
        <table class="w-full">
          <thead>
            <tr><th>Producto</th><th>Stock</th><th>Stock mínimo</th></tr>
          </thead>
          <tbody id="alertsBody">
            <tr><td colspan="3" class="small-note">Sube el archivo de inventario para ver alertas</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <section class="small-note text-gray-600">
      Nota: Si las columnas de costo o método de pago no aparecen en tus CSV, completa los nombres en Excel con encabezados como <em>costo, costo_unitario, metodo_pago, stock_min</em>. El dashboard intenta mapear nombres similares automáticamente.
    </section>

  </main>

<script>
/*
  Dashboard dinámico para Papelería Lupita.
  - Usa PapaParse para leer CSV.
  - Heurísticas para detectar columnas comunes (español/inglés).
  - Agrega gráficos con Chart.js.
*/

const RANGE_START = new Date("2024-07-01T00:00:00");
const RANGE_END = new Date("2024-09-30T23:59:59");

// Utility: detect column by candidates
function findColByKeywords(columns, keywords) {
  const lowerCols = columns.map(c => c.toLowerCase());
  for (let kw of keywords) {
    for (let i = 0; i < lowerCols.length; i++) {
      if (lowerCols[i].includes(kw)) return columns[i];
    }
  }
  return null;
}

// Normalize numeric (strip currency, commas)
function parseNumber(val) {
  if (val === null || val === undefined || val === "") return NaN;
  if (typeof val === "number") return val;
  let s = String(val).trim();
  // remove currency symbols and spaces
  s = s.replace(/[$€£\u20AC,\s]/g, '');
  // handle commas as decimal separators when there is a dot? we assume dot decimal
  s = s.replace(/,/g,''); // remove thousands
  const n = Number(s);
  return isNaN(n) ? NaN : n;
}

// Parse date with fallback
function parseDate(val) {
  if (!val) return null;
  // Try ISO / yyyy-mm-dd
  let d = new Date(val);
  if (!isNaN(d)) return d;
  // Try dd/mm/yyyy
  const parts = String(val).split(/[\/\-\.]/).map(p => p.trim());
  if (parts.length >= 3) {
    // assume dd/mm/yyyy
    let day = parseInt(parts[0],10), month = parseInt(parts[1],10)-1, year = parseInt(parts[2],10);
    if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
      let dd = new Date(year, month, day);
      if (!isNaN(dd)) return dd;
    }
  }
  return null;
}

// Aggregate helpers
function sumMap(map, key, value) {
  map.set(key, (map.get(key) || 0) + value);
}

// Chart instances
let chartDaily = null, chartCategory = null, chartMargin = null, chartEmp = null;

// Elements
const fileVentas = document.getElementById('fileVentas');
const fileInv = document.getElementById('fileInv');
const btnProcess = document.getElementById('btnProcess');

btnProcess.addEventListener('click', () => {
  if (!fileVentas.files.length) { alert('Sube el CSV de ventas.'); return; }
  // inventory optional but recommended
  const invFile = fileInv.files.length ? fileInv.files[0] : null;
  Papa.parse(fileVentas.files[0], {
    header: true, skipEmptyLines: true,
    complete: function(resultsVentas) {
      const ventasData = resultsVentas.data;
      if (invFile) {
        Papa.parse(invFile, { header:true, skipEmptyLines:true, complete: function(resultsInv){
          const invData = resultsInv.data;
          processAll(ventasData, invData);
        }});
      } else {
        processAll(ventasData, []);
      }
    }
  });
});

function processAll(rawVentas, rawInv) {
  // Trim headers
  const ventasColumns = rawVentas.length ? Object.keys(rawVentas[0]) : [];
  const invColumns = rawInv.length ? Object.keys(rawInv[0]) : [];

  // detect possible columns in ventas
  const dateCol = findColByKeywords(ventasColumns, ['fecha','date','dia','day']);
  const qtyCol = findColByKeywords(ventasColumns, ['cantidad','cant','qty','unidades','units']);
  const priceCol = findColByKeywords(ventasColumns, ['precio_unitario','precio','price','venta','total','monto','importe','subtotal']);
  const costCol_sales = findColByKeywords(ventasColumns, ['costo','cost','costo_unitario','precio_costo']);
  const empCol = findColByKeywords(ventasColumns, ['empleado','vendedor','atendio','cajero','seller','vendor','vendedor']);
  const prodCol = findColByKeywords(ventasColumns, ['producto','item','articulo','product','nombre']);
  const catCol = findColByKeywords(ventasColumns, ['categoria','cat','tipo','category']);
  const payCol = findColByKeywords(ventasColumns, ['metodo','pago','forma','payment','payment_method','forma_de_pago']);

  // detect possible columns in inventory
  const invProdCol = findColByKeywords(invColumns, ['producto','item','articulo','product','nombre']);
  const invCatCol = findColByKeywords(invColumns, ['categoria','cat','tipo','category']);
  const invCostCol = findColByKeywords(invColumns, ['costo','cost','precio_costo','costo_unitario']);
  const invStockCol = findColByKeywords(invColumns, ['stock','existencias','cantidad','qty','inventory']);
  const invMinCol = findColByKeywords(invColumns, ['min','stock_min','minimo','reorden','stockmin']);

  // Normalize sales rows into unified structure
  const ventas = rawVentas.map(row => {
    const fecha = parseDate(row[dateCol] ?? row['fecha'] ?? row['Date'] ?? '');
    const cantidad = qtyCol ? parseNumber(row[qtyCol]) : 1;
    const precio = priceCol ? parseNumber(row[priceCol]) : NaN;
    const costo = costCol_sales ? parseNumber(row[costCol_sales]) : NaN;
    const empleado = empCol ? (row[empCol] || '').trim() : (row['vendedor'] || row['Empleado'] || 'Desconocido');
    const producto = prodCol ? (row[prodCol] || '').trim() : (row['producto'] || 'Producto desconocido');
    const categoria = catCol ? (row[catCol] || '').trim() : null;
    const metodo_pago = payCol ? (row[payCol] || '').trim() : null;
    return { fecha, cantidad: isNaN(cantidad)?1:cantidad, precio: isNaN(precio)?NaN:precio, costo: isNaN(costo)?NaN:costo, empleado, producto, categoria, metodo_pago, raw: row };
  });

  // Normalize inventory rows into map by product lowercase (if available)
  const invMap = new Map();
  if (rawInv && rawInv.length && invProdCol) {
    rawInv.forEach(r => {
      const productName = (r[invProdCol] || '').toString().trim().toLowerCase();
      invMap.set(productName, r);
    });
  }

  // Enrich sales with inventory data when cost or category missing
  ventas.forEach(v => {
    if ((!v.costo || isNaN(v.costo)) && invProdCol) {
      const key = v.producto.toLowerCase();
      if (invMap.has(key)) {
        const invRow = invMap.get(key);
        const invCost = invCostCol ? parseNumber(invRow[invCostCol]) : NaN;
        if (!isNaN(invCost)) v.costo = invCost;
      }
    }
    if ((!v.categoria || v.categoria === null) && invProdCol && invCatCol) {
      const key = v.producto.toLowerCase();
      if (invMap.has(key)) {
        const invRow = invMap.get(key);
        v.categoria = invRow[invCatCol] || v.categoria;
      }
    }
  });

  // Filter to Jul 1 - Sep 30 2024
  const ventasPeriodo = ventas.filter(v => v.fecha && v.fecha instanceof Date && !isNaN(v.fecha) && v.fecha >= RANGE_START && v.fecha <= RANGE_END);

  // 1) Tendencia diaria (sum ingresos)
  const dailyMap = new Map(); // date ISO (yyyy-mm-dd) -> ingresos
  const datesSet = new Set();
  ventasPeriodo.forEach(v => {
    const ingreso = (isNaN(v.precio) ? 0 : v.precio) * (isNaN(v.cantidad) ? 1 : v.cantidad);
    const dateIso = v.fecha.toISOString().slice(0,10);
    sumMap(dailyMap, dateIso, ingreso);
    datesSet.add(dateIso);
  });

  // ensure all dates in range are present (if you want continuous series)
  function dateRange(start, end) {
    const arr = [];
    let d = new Date(start);
    while (d <= end) {
      arr.push(new Date(d));
      d.setDate(d.getDate()+1);
    }
    return arr;
  }
  const fullDates = dateRange(RANGE_START, RANGE_END).map(d=>d.toISOString().slice(0,10));
  // create arrays for chart
  const dailyLabels = fullDates; // all days in range
  const dailyValues = dailyLabels.map(lbl => Number((dailyMap.get(lbl) || 0).toFixed(2)));

  // find August peak
  let augPeakDate = null, augPeakValue = 0;
  for (let [k,v] of dailyMap.entries()) {
    if (k.startsWith('2024-08')) {
      if (v > augPeakValue) { augPeakValue = v; augPeakDate = k; }
    }
  }

  // 2) Categoria revenue and percentages
  const catMap = new Map();
  let totalRevenue = 0;
  ventasPeriodo.forEach(v => {
    const ingreso = (isNaN(v.precio) ? 0 : v.precio) * (isNaN(v.cantidad) ? 1 : v.cantidad);
    const cat = v.categoria ? v.categoria : 'Sin categoría';
    sumMap(catMap, cat, ingreso);
    totalRevenue += ingreso;
  });
  // produce sorted arrays
  const catEntries = Array.from(catMap.entries()).map(([k,val]) => ({categoria:k, ingreso: Number(val.toFixed(2)), porcentaje: totalRevenue ? Number(((val/totalRevenue)*100).toFixed(2)) : 0}))
                       .sort((a,b)=>b.ingreso - a.ingreso);

  // 3) Márgenes de ganancia (por producto) => requiere costo
  const prodMap = new Map(); // product -> {ingreso, costo_total, cantidad, categoria}
  ventasPeriodo.forEach(v => {
    const ingreso = (isNaN(v.precio) ? 0 : v.precio) * (isNaN(v.cantidad) ? 1 : v.cantidad);
    const costoUnit = (!isNaN(v.costo) && v.costo !== null) ? v.costo : NaN;
    const costoTotal = (!isNaN(costoUnit) ? costoUnit * v.cantidad : NaN);
    const key = v.producto || 'Producto desconocido';
    const prev = prodMap.get(key) || {ingreso:0, costo_total:0, cantidad:0, category: v.categoria || 'Sin categoría'};
    prev.ingreso += ingreso;
    if (!isNaN(costoTotal)) prev.costo_total += costoTotal;
    prev.cantidad += (isNaN(v.cantidad) ? 1 : v.cantidad);
    prodMap.set(key, prev);
  });

  const prodEntries = Array.from(prodMap.entries()).map(([producto, obj]) => {
    const margenSum = (!isNaN(obj.costo_total) ? obj.ingreso - obj.costo_total : NaN);
    const margenUnit = (obj.cantidad>0 && !isNaN(margenSum)) ? (margenSum / obj.cantidad) : NaN;
    return { producto, ingreso: Number(obj.ingreso.toFixed(2)), costo_total: Number((isNaN(obj.costo_total)?0:obj.costo_total).toFixed(2)), cantidad: obj.cantidad, margen_total: Number((isNaN(margenSum)?0:margenSum).toFixed(2)), margen_unit: isNaN(margenUnit) ? null : Number(margenUnit.toFixed(2)), categoria: obj.category };
  }).sort((a,b) => {
    // sort by margen_unit descending (nulls last)
    if (a.margen_unit === null && b.margen_unit === null) return b.ingreso - a.ingreso;
    if (a.margen_unit === null) return 1;
    if (b.margen_unit === null) return -1;
    return b.margen_unit - a.margen_unit;
  });

  // 4) Empleado performance + payment methods
  const empMap = new Map();
  const empPayMap = new Map(); // empleado -> Map(paymentMethod -> ingreso)
  ventasPeriodo.forEach(v => {
    const ingreso = (isNaN(v.precio) ? 0 : v.precio) * (isNaN(v.cantidad) ? 1 : v.cantidad);
    const emp = v.empleado || 'Desconocido';
    sumMap(empMap, emp, ingreso);
    if (v.metodo_pago) {
      const key = emp;
      if (!empPayMap.has(key)) empPayMap.set(key, new Map());
      const m = empPayMap.get(key);
      sumMap(m, v.metodo_pago, ingreso);
    }
  });
  const empEntries = Array.from(empMap.entries()).map(([k,v]) => ({empleado:k, ingreso: Number(v.toFixed(2))})).sort((a,b)=>b.ingreso - a.ingreso);

  // 5) Inventory alerts
  const alerts = [];
  if (rawInv.length && invProdCol && invStockCol && invMinCol) {
    rawInv.forEach(r => {
      const prod = (r[invProdCol] || '').toString();
      const stock = parseNumber(r[invStockCol]);
      const stockMin = parseNumber(r[invMinCol]);
      if (!isNaN(stock) && !isNaN(stockMin) && stock < stockMin) {
        alerts.push({producto: prod, stock: Number(stock), stock_min: Number(stockMin)});
      }
    });
  }

  // UI updates
  document.getElementById('totalRevenue').innerText = isNaN(totalRevenue) ? 'MXN 0.00' : `MXN ${totalRevenue.toFixed(2)}`;
  document.getElementById('daysCount').innerText = `Fechas registradas: ${dailyMap.size}`;
  if (augPeakDate) {
    document.getElementById('peakAug').innerText = `Pico (ago): ${augPeakDate} — MXN ${augPeakValue.toFixed(2)}`;
  } else {
    document.getElementById('peakAug').innerText = 'Pico (ago): no registrado';
  }

  // Best seller
  if (empEntries.length) {
    const best = empEntries[0];
    document.getElementById('bestSeller').innerText = `${best.empleado} — MXN ${best.ingreso.toFixed(2)}`;
    document.getElementById('sellerDetails').innerText = empEntries.slice(0,5).map(e => `${e.empleado}: MXN ${e.ingreso.toFixed(2)}`).join(' | ');
  } else {
    document.getElementById('bestSeller').innerText = 'No hay datos de vendedores';
    document.getElementById('sellerDetails').innerText = '';
  }

  // Alerts count
  document.getElementById('alertsCount').innerText = alerts.length;

  // Render charts
  renderDailyChart(dailyLabels, dailyValues, augPeakDate, augPeakValue);
  renderCategoryChart(catEntries);
  renderMarginChart(prodEntries);
  renderEmployeeChart(empEntries, empPayMap);

  // Render alerts table
  const alertsBody = document.getElementById('alertsBody');
  alertsBody.innerHTML = '';
  if (alerts.length === 0) {
    alertsBody.innerHTML = '<tr><td colspan="3" class="small-note">No se encontraron productos por debajo del stock mínimo (o faltan columnas stock/stock_min en inventario).</td></tr>';
  } else {
    alerts.forEach(a => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${a.producto}</td><td>${a.stock}</td><td>${a.stock_min}</td>`;
      alertsBody.appendChild(tr);
    });
  }

  // Notes for margin (if costs missing)
  const anyCostAvailable = prodEntries.some(p => p.margen_unit !== null);
  const marginNote = document.getElementById('marginNote');
  if (!anyCostAvailable) {
    marginNote.innerHTML = '<div class="alert">No se encontraron datos de <strong>costo</strong> en ventas ni en inventario. Completa la columna <em>costo</em> o <em>precio_costo</em> en tu CSV de inventario para calcular márgenes reales.</div>';
  } else {
    marginNote.innerText = 'Márgenes calculados por producto (margen unitario).';
  }

  // Category legend text
  const catLegendDiv = document.getElementById('categoryLegend');
  if (catEntries.length) {
    catLegendDiv.innerHTML = catEntries.map(c => `${c.categoria}: MXN ${c.ingreso.toFixed(2)} (${c.porcentaje}%)`).join(' · ');
  } else {
    catLegendDiv.innerText = 'No hay datos por categoría.';
  }

  // Employee note about payment methods
  const empNote = document.getElementById('empNote');
  if (empPayMap.size === 0) {
    empNote.innerText = 'No se detectó columna de método de pago para comparar medios (efectivo/tarjeta).';
  } else {
    empNote.innerText = 'Gráfica incluye desglose por método de pago (stacked).';
  }

  // small daily note
  const dailyNote = document.getElementById('dailyNote');
  dailyNote.innerText = `Serie diaria de ${dailyLabels.length} días. El pico de regreso a clases en agosto (si existe) está resaltado.`;

  // Helper: Destroy old charts if exist
  function destroyChartInstance(ci) {
    if (ci) { try { ci.destroy(); } catch(e){} }
  }

  // Chart render functions
  function renderDailyChart(labels, values, augDate, augVal) {
    destroyChartInstance(chartDaily);
    const ctx = document.getElementById('chartDaily').getContext('2d');
    // Mark august peak point index
    const pointStyles = values.map((v,i) => {
      const lbl = labels[i];
      if (augDate && lbl === augDate) return { r:6 };
      return { r:3 };
    });
    chartDaily = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: 'Ingresos diarios (MXN)',
          data: values,
          tension: 0.2,
          fill: true,
          backgroundColor: 'rgba(59,130,246,0.08)',
          borderColor: 'rgba(59,130,246,1)',
          pointRadius: pointStyles.map(p=>p.r)
        }]
      },
      options: {
        interaction: { mode: 'index', intersect: false },
        plugins: {
          tooltip: {
            callbacks: {
              label: ctx => `MXN ${Number(ctx.raw).toFixed(2)}`
            }
          }
        },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 12 } },
          y: { beginAtZero: true }
        }
      }
    });
  }

  function renderCategoryChart(catEntries) {
    destroyChartInstance(chartCategory);
    const ctx = document.getElementById('chartCategory').getContext('2d');
    const labels = catEntries.map(c => c.categoria);
    const data = catEntries.map(c => c.ingreso);
    chartCategory = new Chart(ctx, {
      type: 'pie',
      data: { labels, datasets: [{ data, backgroundColor: generatePalette(labels.length) }] },
      options: { plugins: { legend: { position: 'bottom' } } }
    });
  }

  function renderMarginChart(prodEntries) {
    destroyChartInstance(chartMargin);
    const ctx = document.getElementById('chartMargin').getContext('2d');
    // show top N products by ingreso or margin
    const top = prodEntries.slice(0, 12);
    const labels = top.map(t => t.producto + (t.categoria ? ` (${t.categoria})` : ''));
    const dataMargin = top.map(t => (t.margen_unit === null ? 0 : t.margen_unit));
    const dataHasMargin = top.some(t => t.margen_unit !== null);
    chartMargin = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: dataHasMargin ? 'Margen unitario (MXN)' : 'Margen (no disponible, revisar costos)',
          data: dataMargin,
          backgroundColor: generatePalette(labels.length)
        }]
      },
      options: {
        indexAxis: 'y',
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: ctx => {
                const val = ctx.raw;
                return dataHasMargin ? `MXN ${Number(val).toFixed(2)} (margen unitario)` : 'Costo no disponible';
              }
            }
          }
        },
        scales: { x: { beginAtZero:true } }
      }
    });
  }

  function renderEmployeeChart(empEntries, empPayMap) {
    destroyChartInstance(chartEmp);
    const ctx = document.getElementById('chartEmp').getContext('2d');

    // If empPayMap present, create stacked bars per payment method
    if (empPayMap.size > 0) {
      const empleados = empEntries.map(e => e.empleado);
      // collect unique payment methods across all employees
      const paySet = new Set();
      empPayMap.forEach((m, emp) => { for (let k of m.keys()) paySet.add(k); });
      const payMethods = Array.from(paySet);
      const datasets = payMethods.map((pm, idx) => {
        const data = empleados.map(emp => {
          const m = empPayMap.get(emp);
          if (!m) return 0;
          return Number((m.get(pm) || 0).toFixed(2));
        });
        return { label: pm, data, stack: 'stack1' };
      });
      chartEmp = new Chart(ctx, {
        type: 'bar',
        data: { labels: empleados, datasets },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: { x: { stacked: true }, y: { stacked: true, beginAtZero:true } }
        }
      });
    } else {
      // simple bar of ingresos per employee
      const labels = empEntries.map(e => e.empleado);
      const data = empEntries.map(e => e.ingreso);
      chartEmp = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label:'Ingresos por empleado (MXN)', data }] },
        options: { plugins: { legend: { display:false } }, scales: { y: { beginAtZero:true } } }
      });
    }
  }

  // color palette helper
  function generatePalette(n) {
    const base = [
      '#2563eb','#fb7185','#34d399','#f59e0b','#60a5fa','#f472b6','#10b981','#f97316',
      '#8b5cf6','#06b6d4','#ef4444','#a3e635'
    ];
    const out = [];
    for (let i=0;i<n;i++) out.push(base[i % base.length]);
    return out;
  }

} // end processAll

</script>
</body>
</html>
